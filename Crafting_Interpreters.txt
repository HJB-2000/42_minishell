# Single-pass compilation

A compiler has roughly two jobs. 
    |--> parse the user source code to understand what it means
    |--> take that knowledge and outputs low level instructions that produce the same simantics.

Ⅰ- many programming language split those two roles in two separete passes in the implimentation 
    |--> a parser produces an AST
    |--> a code generator traverses the AST and outputs target code.

one of the problem in the more-passes compilers is in old days computers did not have enought memory 
    to store an entire source file's AST;


Ⅱ - Parsing Tokens
    1- grammar

        expression  --> identifier
                    | grouping
                    | logical operator
                    | wildcard
                    | command builtin
                    | redirections
                    | pipes
                    | environment variables



        identifier          --> NUMBER | STRING | "..." | '...'
        pipes               --> '|'
        logical operator    --> '&&' | '||'
        
        grouping            --> "("expression")"
        wildcards           --> '*...'
        redirections        --> '>>' | '<<' | '<' | '>'
        environment         --> '$...' | '$?'



        
    
    2 - precedence : determine which expression is evaluated first in an cmd-line containing a mixture
            of different expresion. so we need some sort of precedence rules to manage this so expressions
            whith higher precedence get evaluated befor the ones with lower precedence
    3 - associativity : determines which expression is goint to be evaluated first in a series of 
            of the same expression


ⅡⅠ - 
    1- precedence determines who binds tighter first ---LOCALLY---
    2- lowest precedence operator becomes the root of the whole AST

    ---> precedence decides grouping locally, not necessarily the root of the AST
        | -when we scan, high precedence operator glue things together first
        | - low level precedence operator connect the bigger pieces
        | - the root of the AST is the "weakest link", meaning the lowest precedence operator at the top level 

    3- example 
        a && b || c && d || e
        |
        |----> && has higher precedence than ||
        |----> so a && b , c && d group togther ===> (a && b) || (c && d) || e
        |----> then || grouping so ====> ( (a && b) || (c && d) ) || e
                            
                            ||
                           /  \
                        ||     e
                       /  \
                     &&    &&
                    /  \  /  \
                   a   b  c   d 
    4 - Notes
        |---> the root is determined by the weakest operator golobaly
        |---> higher precedence operators arr inside subtrees lower down



..- EVALUATING EXPRESSION 
        1- there all manner of ways that language implementation make a computer do what the user's source code commands.
            |---> they can compile it to machine code 
            |---> or translate ot to another high-level language
            |---> or reduce it to some bytecode format for a virtual machine to run.

{we can evaluet an expression syntax and produce a certain value}
====> so all we need is a code that evaluate the AST tree and produce a result
    so we end up with two important questions :
        1- what kinds of values do we need to produce ?
        2- How do we orgnize those chunks of codes
        
        we need to figure out a way that goint to help us storing the tokens and there values

        i am starting with the question how we are going to organize the lexems and how to create an AST ?

Ⅰ-- evaluating Expressions 
        as a readed in book we need an implementation of code to exercise a sort of logical evaluation for 
                each kind of expression we can parse.
        so we can stuff the lexem (Tokens) into the syntax tree node, in something like ```interpret()``` method.
        in effect we can tell each syntax tree node "interpret thyself". this called !"interpretwer design pattern."









this if from the book cookbash

1 - each line that the shell reads from the STDIN or form a script is called pipline because it contains one or more 
        commands sperated by zero or more pipe character (|).

    *1- split the command-line into Tokens that are separete by the set of matacharacters-space,tab,newline,;,(,),<,>,|,& .
            and type of Tokens include words, keywords, I/O redirections, simicolons.
    *2-  check the first token of each command to see if it is a keyword with no quotes or backslashes 
            if it's not an opening keyword (control-structure opener, function, {}, ()) then the command is a compound command
            the shell sets things up internally for the compound command, reads the next command, and opener
    *3- check the first words of each command against the list of aliases. if a match is found it substitules the alias's definition
            and goes back to the first step; otherwise it to step 4
            the should be recursive allowing aliases and keywords to be defined
    *4- Performs brace expansion. 
    *5- substitutes the user's home directory ($HOME) for tild if it is at the beginning of a word. substitutes the user's home
            directory for ~user
    *6- Performs parameters (variables) substitution for any expresion that starts with dollor sign ($).
    *7- Does command substitution for any expresion of the form STRING
    *8- evaluate arthmitic expression of the form STRING
    *9- Takes the parts of the line that resulted form the parameter, command, and arithmitic substitution and split 
            them into words again. 
    *10- Performs pathname expansion aka wildcard expansion for any occurrences of *, ? , []
    *11- Uses the first word as a command by looking up its source in the following order 
            - as a function command 
            - then as a builtin command
            - the as a file in any of the directories in $PATH 
    *12- Runs the command after setting up I/O redirections and other such things